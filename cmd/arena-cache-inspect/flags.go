package main

// flags.go centralises command‑line parsing for the arena‑cache inspector CLI.
// The tool is intentionally dependency‑free, relying only on the standard
// library `flag` package so that the resulting binary remains tiny and CGO‑
// free.  All behavioural knobs are defined here; `main.go` simply consumes the
// populated *options and executes the requested action.
//
// Synopsis (auto‑generated by `flag.Usage`):
//   arena-cache-inspect [flags]
//
// By default the tool prints a one‑shot human‑readable snapshot (hits/misses,
// live arena bytes) obtained from a local HTTP debug endpoint exported by the
// application embedding arena‑cache.  Flags allow JSON output, periodic
// streaming, and pprof snapshot dumps.
//
// © 2025 arena-cache authors. MIT License.

import (
	"flag"
	"fmt"
	"os"
	"time"
)

/* -------------------------------------------------------------------------
   Option structure used by the rest of CLI
   ------------------------------------------------------------------------- */

type options struct {
    target   string        // base URL of the target process (http/https, host:port)
    json     bool          // output machine‑parsable JSON instead of pretty text
    watch    bool          // continuously refresh until Ctrl‑C
    interval time.Duration // refresh interval for --watch (default 2s)

    heapProfile      string // if set, download /debug/pprof/heap to this file
    goroutineProfile string // if set, download /debug/pprof/goroutine to this file

    version bool // print version and exit
}

/* -------------------------------------------------------------------------
   parseFlags – entry point
   ------------------------------------------------------------------------- */

func parseFlags() *options {
    opts := &options{}

    flag.StringVar(&opts.target, "addr", "http://localhost:6060", "base URL where arena‑cache debug endpoint is exposed (scheme://host:port)")
    flag.BoolVar(&opts.json, "json", false, "print output as compact JSON")
    flag.BoolVar(&opts.watch, "watch", false, "continuously refresh the snapshot")
    flag.DurationVar(&opts.interval, "interval", 2*time.Second, "refresh interval in --watch mode")

    flag.StringVar(&opts.heapProfile, "heap", "", "write heap profile to the specified file (triggers one‑shot dump and exits)")
    flag.StringVar(&opts.goroutineProfile, "goroutine", "", "write goroutine profile to the specified file (triggers one‑shot dump and exits)")

    flag.BoolVar(&opts.version, "version", false, "print CLI and library version")

    flag.Usage = usage
    flag.Parse()

    // Validate mutually exclusive combinations.
    if opts.watch && (opts.heapProfile != "" || opts.goroutineProfile != "") {
        fmt.Fprintln(os.Stderr, "-watch cannot be used together with -heap or -goroutine")
        os.Exit(2)
    }
    if opts.interval <= 0 {
        fmt.Fprintln(os.Stderr, "-interval must be positive")
        os.Exit(2)
    }
    return opts
}

/* -------------------------------------------------------------------------
   Custom usage printout
   ------------------------------------------------------------------------- */

func usage() {
    fmt.Fprintf(flag.CommandLine.Output(), "arena-cache-inspect – live diagnostics for arena‑cache backed services\n\n")
    fmt.Fprintf(flag.CommandLine.Output(), "Usage:\n  %s [flags]\n\n", os.Args[0])
    fmt.Fprintf(flag.CommandLine.Output(), "Flags:\n")
    flag.PrintDefaults()
    fmt.Fprintf(flag.CommandLine.Output(), `\nExamples:
  # One‑shot pretty print (default localhost:6060)
  arena-cache-inspect

  # Query remote host and output JSON
  arena-cache-inspect -addr http://myhost:7070 -json

  # Continuous watch every 5 seconds
  arena-cache-inspect -watch -interval 5s

  # Capture heap profile to file
  arena-cache-inspect -heap heap.out
`)
}
